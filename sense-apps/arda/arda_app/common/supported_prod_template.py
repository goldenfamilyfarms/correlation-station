import logging

from copy import deepcopy

from arda_app.bll.type_2_hub_work import type_2_hub_work_main
from arda_app.bll.models.payloads.type_2_hub_work import Type2HubWorkPayloadModel
from arda_app.bll.net_new.create_shelf import create_shelf_main
from arda_app.bll.models.payloads.create_shelf import CreateShelfPayloadModel
from arda_app.bll.serviceable_shelf import serviceable_shelf_main
from arda_app.bll.models.payloads.serviceable_shelf import ServiceableShelfPayloadModel
from arda_app.bll.net_new.create_mtu_transport import create_mtu_new_build_transport_main
from arda_app.bll.models.payloads.create_mtu_transport import CreateMTUTransportPayloadModel
from arda_app.bll.net_new.assign_uplinks_and_handoffs import assign_uplinks_and_handoffs_main
from arda_app.bll.models.payloads.assign_handoffs_and_uplinks import AssignHandoffsAndUplinksPayloadModel
from arda_app.bll.net_new.assign_parent_paths import assign_parent_paths_main
from arda_app.bll.models.payloads.assign_parent_paths import AssignParentPathsPayloadModel
from arda_app.bll.transport_path import qc_transport_path_main
from arda_app.bll.models.payloads.qc_transport_path import QCTransportPayloadModel
from arda_app.bll.assign.enni import assign_enni_main
from arda_app.bll.models.payloads.assign_enni import AssignEnniPayloadModel
from arda_app.bll.assign.evc import assign_evc_main
from arda_app.bll.models.payloads.assign_evc import AssignEvcPayloadModel
from arda_app.bll.assign.gsip import assign_gsip_main
from arda_app.bll.models.payloads.assign_gsip import AssignGsipPayloadModel
from arda_app.bll.assign.vpls import assign_vpls_main
from arda_app.bll.models.payloads.elan_add_vpls import ElanAddVplsPayloadModel

from arda_app.dll.granite import get_granite
from arda_app.dll.sense import post_sense, put_sense, get_sense
from common_sense.common.errors import abort


logger = logging.getLogger(__name__)


class SupportedProdTemplate:
    def __init__(self, payload: object):
        self.order = ()
        self.payload = payload
        self.carryover_payload = {}
        self.execution_output = []

    # Relationship maps between orders, tasks, microservices, and required payload keys
    # An 'order' is a tuple containing its descriptors (e.g. service type, build type)
    # Associated with an 'order' is its specific list of 'tasks' to be completed
    common_tasks = ["Assign_Uplinks", "Assign_Handoffs", "Assign_Parent_Paths"]
    cj_tasks = deepcopy(common_tasks)
    cj_tasks.insert(0, "Create_CPE_Shelf")
    no_cj_tasks = deepcopy(common_tasks)
    no_cj_tasks[0] = "Serviceable_Shelf"
    cj_mtu_tasks = deepcopy(cj_tasks)
    cj_mtu_tasks[0:1] = ["Create_MTU_Shelf", "Create_CPE_Shelf", "Create_MTU_Transport"]
    qc_tasks = deepcopy(cj_tasks)
    qc_tasks.insert(0, "Quick_Connect_Transport_Path")
    type2_task = deepcopy(common_tasks)
    type2_task.insert(0, "Type2_Hub_Work")
    type2_task.insert(1, "Create_CPE_Shelf")

    order_tasks_map = {
        ("net_new_cj", "MTU New Build"): cj_mtu_tasks,
        ("net_new_cj", "Home Run"): cj_tasks,
        ("net_new_cj", "STU (Single Tenant Unit)"): cj_tasks,
        ("net_new_cj", "Strip Mall"): cj_tasks,
        ("net_new_serviceable", "Null"): no_cj_tasks,
        ("net_new_no_cj", "Null"): no_cj_tasks,
        ("net_new_qc", "Null"): qc_tasks,
        ("net_new_no_cj", "type2_hub"): type2_task,
        ("net_new_serviceable", "type2_hub"): type2_task,
        # SAVE key:value pair below for testing purposes
        ("net_new_cj", "home_run"): ["GET_ISP_Group"],
    }

    # Map of specific keys to create when building payload for the specified task/endpoint
    #  Payload keys for the listed endpoint whose values are retrieved from the carryover payload
    #  Carryover payload contains the response key:value pairs generated by previous tasks/endpoints
    #  Example:
    #    ("net_new_qc_LEGACY", None): [
    #        (
    #            "MTU_Uplink_To_CPE_QC",  <-- Task/endpoint to check
    #            [
    #                "port_inst_id",
    #                "service",
    #            ],  <-- Key(s) needed to help build the payload for this endpoint (keys-to-create)
    #            [
    #                "port_inst_id",
    #                "service_type",
    #            ]  <-- Key(s) whose value(s) is/are pulled from carryover payload (carryover-keys)
    #                   1-to-1 match between keys-to-create and carryover-keys
    #                   (to support difference in key names, if needed)
    #        ),
    #    ],
    assign_uplinks_keys_to_build = [
        "circ_path_inst_id",
        "mtu_tid",
        "cpe_tid",
        "mtu_uplink",
        "mtu_pe_path",
        "cpe_uplink",
        "cpe_handoff",
        "cpe_trunked_path",
        "zw_path",
        ("third_party_provided_circuit",),
    ]
    assign_uplinks_carryover_keys_to_copy = [
        "circ_path_inst_id",
        "mtu_tid",
        "cpe_tid",
        "mtu_uplink",
        "mtu_pe_path",
        "cpe_uplink",
        "cpe_handoff",
        "cpe_trunked_path",
        "zw_path",
        ("third_party_provided_circuit",),
    ]
    assign_vgw_uplinks_keys_to_build = ["circ_path_inst_id", "cpe_tid", "cpe_uplink", "zw_path", "service_code"]
    assign_vgw_uplinks_carryover_keys_to_copy = [
        "circ_path_inst_id",
        "vgw_tid",
        "vgw_uplink",
        "circ_path_inst_id",
        "service_code",
    ]
    assign_handoffs_keys_to_build = [
        "circ_path_inst_id",
        "mtu_tid",
        "cpe_tid",
        "mtu_uplink",
        "cpe_uplink",
        "cpe_handoff",
        "cpe_trunked_path",
        "cpe_handoff_paid",
        "zw_path",
        ("third_party_provided_circuit",),
    ]
    assign_handoffs_carryover_keys_to_copy = [
        "circ_path_inst_id",
        "mtu_tid",
        "cpe_tid",
        "mtu_uplink",
        "cpe_uplink",
        "cpe_handoff",
        "cpe_trunked_path",
        "cpe_handoff_paid",
        "zw_path",
        ("third_party_provided_circuit",),
    ]
    assign_handoffs_carryover_keys_to_copy_for_serviceable_type = [
        "circ_path_inst_id",
        "mtu_tid",
        "cpe_tid",
        "mtu_uplink",
        "cpe_uplink",
        "cpe_handoff",
        "cpe_trunked_path",
        "cpe_handoff_paid",
        "zw_transport_path",
        ("third_party_provided_circuit",),
    ]
    assign_vgw_handoffs_keys_to_build = [
        "circ_path_inst_id",
        "cpe_tid",
        "cpe_handoff",
        "cpe_handoff_paid",
        "service_code",
    ]
    assign_vgw_handoffs_carryover_keys_to_copy = [
        "circ_path_inst_id",
        "vgw_tid",
        "vgw_handoff",
        "vgw_handoff_paid",
        "service_code",
    ]
    order_task_carryover_payload_keys_map = {
        ("net_new_cj", "MTU New Build"): [
            (
                "Create_MTU_Transport",
                ["mtu_tid", "cpe_tid", "mtu_handoff", "cpe_uplink"],
                ["mtu_tid", "cpe_tid", "mtu_handoff", "cpe_uplink"],
            ),
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_cj", "Home Run"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_cj", "STU (Single Tenant Unit)"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_cj", "Strip Mall"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_serviceable", "Null"): [
            (
                "Assign_Handoffs",
                assign_handoffs_keys_to_build,
                assign_handoffs_carryover_keys_to_copy_for_serviceable_type,
            ),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_no_cj", "Null"): [
            (
                "Assign_Handoffs",
                assign_handoffs_keys_to_build,
                assign_handoffs_carryover_keys_to_copy_for_serviceable_type,
            ),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_qc", "Null"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
            ("Assign_VGW_Uplinks", assign_vgw_uplinks_keys_to_build, assign_vgw_uplinks_carryover_keys_to_copy),
            ("Assign_VGW_Handoffs", assign_vgw_handoffs_keys_to_build, assign_vgw_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_no_cj", "type2_hub"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
        ],
        ("net_new_serviceable", "type2_hub"): [
            ("Assign_Uplinks", assign_uplinks_keys_to_build, assign_uplinks_carryover_keys_to_copy),
            ("Assign_Handoffs", assign_handoffs_keys_to_build, assign_handoffs_carryover_keys_to_copy),
        ],
    }

    # One-to-one relationship between a 'task' and the main func to execute it
    task_microservice_main_funcs = {
        "Type2_Hub_Work": type_2_hub_work_main,
        "Create_MTU_Shelf": create_shelf_main,
        "Create_CPE_Shelf": create_shelf_main,
        "Create_VGW_Shelf": create_shelf_main,
        "Serviceable_Shelf": serviceable_shelf_main,
        "Create_MTU_Transport": create_mtu_new_build_transport_main,
        "Assign_Uplinks": assign_uplinks_and_handoffs_main,
        "Assign_VGW_Uplinks": assign_uplinks_and_handoffs_main,
        "Assign_Handoffs": assign_uplinks_and_handoffs_main,
        "Assign_VGW_Handoffs": assign_uplinks_and_handoffs_main,
        "Assign_Parent_Paths": assign_parent_paths_main,
        "Quick_Connect_Transport_Path": qc_transport_path_main,
        # Product Uniqueness calls
        "Assign_ENNI": assign_enni_main,
        "Assign_EVC": assign_evc_main,
        "Assign_GSIP_Attributes": assign_gsip_main,
        "Assign_VPLS": assign_vpls_main,
    }

    task_main_func_to_model_map = {
        "Type2_Hub_Work": Type2HubWorkPayloadModel,
        "Create_MTU_Shelf": CreateShelfPayloadModel,
        "Create_CPE_Shelf": CreateShelfPayloadModel,
        "Create_VGW_Shelf": CreateShelfPayloadModel,
        "Serviceable_Shelf": ServiceableShelfPayloadModel,
        "Create_MTU_Transport": CreateMTUTransportPayloadModel,
        "Assign_Uplinks": AssignHandoffsAndUplinksPayloadModel,
        "Assign_VGW_Uplinks": AssignHandoffsAndUplinksPayloadModel,
        "Assign_Handoffs": AssignHandoffsAndUplinksPayloadModel,
        "Assign_VGW_Handoffs": AssignHandoffsAndUplinksPayloadModel,
        "Assign_Parent_Paths": AssignParentPathsPayloadModel,
        "Quick_Connect_Transport_Path": QCTransportPayloadModel,
        # Product Uniqueness calls
        "Assign_ENNI": AssignEnniPayloadModel,
        "Assign_EVC": AssignEvcPayloadModel,
        "Assign_GSIP_Attributes": AssignGsipPayloadModel,
        "Assign_VPLS": ElanAddVplsPayloadModel,
    }

    # This defines the required payload keys to submit when calling a SEnSE endpoint for a 'task'
    #  Payload key represented as a string means its value is required
    #  Payload key represented as a string in a single-element tuple means this key is optional
    task_payload_keys_map = {
        "Type2_Hub_Work": [
            "cid",
            "third_party_provided_circuit",
            "service_provider",
            "service_provider_uni_cid",
            "service_provider_cid",
            "service_provider_vlan",
            "spectrum_buy_nni_circuit_id",
        ],
        "Create_MTU_Shelf": ["service_type", "product_name", "cid", "build_type", "role", "side"],
        "Create_CPE_Shelf": [
            "service_type",
            "product_name",
            "cid",
            "build_type",
            "connector_type",
            "uni_type",
            "role",
            "side",
            ("service_code",),
            ("cpe_gear",),
            ("third_party_provided_circuit",),
        ],
        "Create_VGW_Shelf": [
            "service_type",
            "product_name",
            "cid",
            "build_type",
            "connector_type",
            ("number_of_circuits_in_group",),
            ("service_code",),
            ("number_of_b_channels",),
            "uni_type",
            "role",
            "side",
        ],
        "Create_MTU_Transport": [
            "service_type",
            "product_name",
            "cid",
            "build_type",
            "mtu_tid",
            "cpe_tid",
            "mtu_handoff",
            "cpe_uplink",
            "side",
        ],
        "Serviceable_Shelf": [
            "cid",
            ("agg_bandwidth",),
            "connector_type",
            "uni_type",
            "side",
            "product_name",
            ("third_party_provided_circuit",),
        ],
        "Assign_Uplinks": [
            "service_type",
            "product_name",
            "cid",
            "circ_path_inst_id",
            "build_type",
            ("mtu_tid",),
            ("cpe_tid",),
            ("mtu_uplink",),
            ("mtu_pe_path",),
            ("cpe_uplink",),
            ("cpe_handoff",),
            ("cpe_trunked_path",),
            ("zw_path",),
            "side",
            "port_role",
            ("third_party_provided_circuit",),
        ],
        "Assign_VGW_Uplinks": [
            "service_type",
            "product_name",
            "cid",
            "circ_path_inst_id",
            ("number_of_circuits_in_group",),
            ("service_code",),
            "build_type",
            "cpe_tid",
            "cpe_uplink",
            "zw_path",
            "side",
            "port_role",
        ],
        "Assign_Handoffs": [
            "service_type",
            "product_name",
            "cid",
            "circ_path_inst_id",
            "build_type",
            ("mtu_tid",),
            "cpe_tid",
            ("mtu_uplink",),
            ("cpe_uplink",),
            ("cpe_handoff",),
            ("cpe_trunked_path",),
            ("cpe_handoff_paid",),
            ("zw_path",),
            "side",
            "port_role",
            ("third_party_provided_circuit",),
        ],
        "Assign_VGW_Handoffs": [
            "service_type",
            "product_name",
            "cid",
            "circ_path_inst_id",
            ("number_of_circuits_in_group",),
            ("service_code",),
            "build_type",
            "cpe_tid",
            "cpe_handoff",
            "cpe_handoff_paid",
            "side",
            "port_role",
        ],
        "Assign_Parent_Paths": [
            "cid",
            ("number_of_circuits_in_group",),
            "service_type",
            "product_name",
            "side",
            ("third_party_provided_circuit",),
        ],
        "Assign_ENNI": ["side", "cid", "product_name", "spectrum_primary_enni"],
        "Assign_EVC": ["side", "cid", "product_name"],
        "Assign_VPLS": ["cid", "product_name", "create_new_elan_instance", "customers_elan_name", "granite_site_name"],
        "Assign_GSIP_Attributes": [
            "cid",
            "product_name",
            ("third_party_provided_circuit",),
            ("service_provider",),
            ("service_provider_uni_cid",),
            ("service_provider_cid",),
            ("class_of_service_type",),
        ],
        "Assign_Relationship": ["cid", "related_cid", "product_name"],
        "Quick_Connect_Transport_Path": ["cid", "agg_bandwidth", "service_type", "product_name", "side"],
        # SAVE endpoint:payload keys below for testing purposes
        "GET_ISP_Group": ["clli", ("prism_id",), "side"],
    }

    # An 'order' is defined as a tuple comprised of service and/or build type descriptors
    supported_orders = (
        ("net_new_cj", "MTU New Build"),
        ("net_new_qc", "Null"),
        ("net_new_cj", "Home Run"),
        ("net_new_cj", "STU (Single Tenant Unit)"),
        ("net_new_cj", "Strip Mall"),
        ("net_new_serviceable", "Null"),
        ("net_new_no_cj", "Null"),
        # SAVE order below for testing purposes
        ("net_new_cj", "home_run"),
        ("net_new_no_cj", "type2_hub"),
        ("net_new_serviceable", "type2_hub"),
    )

    # Logical steps needed per product
    FIA_uniqueness_task_list = ["Assign_GSIP_Attributes"]

    ELAN_uniqueness_task_list = ["Assign_VPLS", "Assign_GSIP_Attributes"]

    HVF_uniqueness_task_list = ["Assign_GSIP_Attributes"]

    RPHY_uniqueness_task_list = ["Assign_GSIP_Attributes"]

    CEA_uniqueness_task_list = ["Assign_EVC", "Assign_GSIP_Attributes", "Assign_ENNI"]

    EPL_uniqueness_task_list = ["Assign_EVC", "Assign_GSIP_Attributes"]

    WIA_uniqueness_task_list = ["Assign_GSIP_Attributes"]

    VGW_uniqueness_task_list = [
        "Assign_GSIP_Attributes",
        "Create_VGW_Shelf",
        "Assign_VGW_Uplinks",
        "Assign_VGW_Handoffs",
    ]

    # Functions to access the class maps, lists, and tuples.
    #  To encourage the use of local copies of these data structures
    #  for reference and manipulation within a calling function, instead of
    #  changing them at the class-level.
    def get_order_tasks_map(self):
        return self.order_tasks_map

    def get_task_microservice_main_funcs(self):
        return self.task_microservice_main_funcs

    def get_task_payload_keys_map(self):
        return self.task_payload_keys_map

    def get_order_task_carryover_payload_keys_map(self):
        return self.order_task_carryover_payload_keys_map

    def get_FIA_uniqueness_task_list(self):
        return self.FIA_uniqueness_task_list

    def get_ELAN_uniqueness_task_list(self):
        return self.ELAN_uniqueness_task_list

    def get_HVF_uniqueness_task_list(self):
        return self.HVF_uniqueness_task_list

    def get_RPHY_uniqueness_task_list(self):
        return self.RPHY_uniqueness_task_list

    def get_CEA_uniqueness_task_list(self):
        return self.CEA_uniqueness_task_list

    def get_EPL_uniqueness_task_list(self):
        return self.EPL_uniqueness_task_list

    def get_WIA_uniqueness_task_list(self):
        return self.WIA_uniqueness_task_list

    def get_VGW_uniqueness_task_list(self):
        return self.VGW_uniqueness_task_list

    def get_supported_orders(self):
        return self.supported_orders

    # Main methods
    def service_type_builder(self, payload):
        if not payload:
            abort(500, "SupportedProdTemplate.service_type_builder - Payload is unknown")
        # create order
        self.order = self.create_order(payload.get("service_type"), payload.get("build_type"))
        logger.debug(f"SupportedProdTemplate.service_type_builder - Circuit Design order - {self.order}")
        # is order supported?
        order_is_supported = self.is_order_supported(payload)
        if order_is_supported:
            # get list of tasks for order
            task_list = self.get_list_of_tasks_for_order()
            logger.debug(f"SupportedProdTemplate.service_type_builder - Task list for order - {task_list}")
            # for each task in order, call its associated microservice, if available
            self.execution_output.append("====================================================================")
            self.execution_output.append(
                f"Circuit Design order for {payload.get('product_name')}: {payload.get('side')} of {self.order}"
            )
            self.execute_each_task(task_list, payload)

    def product_uniqueness_identifier(self):
        # Retrieve payload to start working on Circuit Design order
        payload_list = self.get_payload_for_each_side()

        if not payload_list:
            abort(500, "SupportedProdTemplate.product_uniqueness_identifier - Payload list is unknown")
        for data in payload_list:
            # For Hosted Voice - (DOCSIS) and Hosted Voice - (Overlay) products
            if data.get("product_name") in ("Hosted Voice - (DOCSIS)", "Hosted Voice - (Overlay)"):
                # Skip a_side for Hosted Voice
                if data.get("side", "") != "z_side":
                    continue

                get_granite_url = f"/circuitSites?CIRCUIT_NAME={data.get('cid')}&PATH_CLASS=P"
                cid_info = get_granite(get_granite_url)
                try:
                    circ_path_inst_id = cid_info[0]["CIRC_PATH_INST_ID"]
                except (TypeError, KeyError, IndexError):
                    abort(500, "No data from granite")

                return {"circ_path_inst_id": circ_path_inst_id}
                # self.order = self.create_order(data.get("service_type"), data.get("build_type"))
                # if self.is_order_supported(data):
                #     self.execution_output.append(
                #         f"Circuit Design order for {data.get('product_name')}: {data.get('side')} of {self.order}"
                #     )
                #     self.execution_output.append({"circ_path_inst_id": circ_path_inst_id})
                #     return self.execution_output
            # Initialize carryover payload for each side
            self.carryover_payload = data

            # If DOCSIS skip service type builder
            if data.get("product_name") != "SIP - Trunk (DOCSIS)":
                # Base construction
                self.service_type_builder(data)

            # Product uniqueness per payload
            self.execution_output.append("  -- Product Uniqueness --")
            if data.get("product_name") in {"Fiber Internet Access", "Carrier Fiber Internet Access"}:
                task_list = self.get_FIA_uniqueness_task_list()
            elif data.get("product_name") == "EP-LAN (Fiber)":
                task_list = self.get_ELAN_uniqueness_task_list()
            elif data.get("product_name") == "FC + Remote PHY":
                task_list = self.get_RPHY_uniqueness_task_list()
            elif data.get("product_name") == "Carrier E-Access (Fiber)":
                task_list = self.get_CEA_uniqueness_task_list()
            elif data.get("product_name") == "EPL (Fiber)" and data.get("side", "") != "a_side":
                task_list = self.get_EPL_uniqueness_task_list()
            elif data.get("product_name") == "Hosted Voice - (Fiber)":
                task_list = self.get_HVF_uniqueness_task_list()
            elif data.get("product_name") in {
                "PRI Trunk (Fiber)",
                "PRI Trunk(Fiber) Analog",
                "PRI Trunk (DOCSIS)",
                "SIP - Trunk (Fiber)",
                "SIP Trunk(Fiber) Analog",
                "SIP - Trunk (DOCSIS)",
            }:
                task_list = self.get_VGW_uniqueness_task_list()
            elif "Wireless Internet Access" in data.get("product_name"):
                task_list = self.get_WIA_uniqueness_task_list()
            else:
                task_list = []
            self.execute_each_task(task_list, data)
        return self.execution_output

    # Order functions
    def create_order(self, service_type, build_type):
        if not service_type:
            abort(500, "SupportedProdTemplate.create_order - Service type is unknown")
        elif not build_type:
            order = (service_type, None)
        else:
            order = (service_type, build_type)
        return order

    def is_order_supported(self, payload):
        if not payload:
            abort(500, "SupportedProdTemplate.is_order_supported - Payload is unknown")
        if self.order not in self.get_supported_orders():
            abort(
                500,
                f"SupportedProdTemplate.is_order_supported - "
                f"Circuit Design order {self.order} for {payload.get('product_name')} is unsupported",
            )
        return True

    # Payload functions
    def is_payload_key_optional(self, key):
        if not key:
            abort(500, "SupportedProdTemplate.is_payload_key_optional - Key is unknown")
        return True if isinstance(key, tuple) else False

    def add_side_info_to_payload(self, side, payload):
        """Introduces internal field/key 'side' into payload for downstream SEnSE endpoint usage"""
        if not side:
            abort(500, "SupportedProdTemplate.add_side_info_to_payload - Side is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.add_side_info_to_payload - Payload is unknown")
        payload["side"] = side
        return payload

    def add_role_info_to_payload(self, role, payload):
        """Introduces internal field/key 'role' into payload for downstream SEnSE endpoint usage"""
        if not role:
            abort(500, "SupportedProdTemplate.add_role_info_to_payload - Role is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.add_role_info_to_payload - Payload is unknown")
        payload["role"] = role
        return payload

    def add_port_role_info_to_payload(self, port_role, payload):
        """Introduces internal field/key 'port_role' into payload for downstream SEnSE endpoint usage"""
        if not port_role:
            abort(500, "SupportedProdTemplate.add_port_role_info_to_payload - Port role is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.add_port_role_info_to_payload - Payload is unknown")
        payload["port_role"] = port_role
        return payload

    def update_carryover_payload(self, resp):
        """Need to append key:value pairs from an endpoint response to self.carryover_payload"""
        if not resp:
            abort(500, "SupportedProdTemplate.update_carryover_payload - Response data is unknown")
        if not isinstance(resp, str):
            for key in resp.keys():
                self.carryover_payload[key] = resp.get(key)

    def get_payload_for_each_side(self):
        payload_to_change = {}
        payload_list = []
        if "a_side_info" in self.payload.keys():
            payload_to_change = self.payload.get("a_side_info")
            # Payload mod (1 of 5): Add internal field/key 'side' into payload to retain side info
            #  ignore a_side payload if product name is 'Carrier E-Access (Fiber)'
            if payload_to_change.get("product_name") != "Carrier E-Access (Fiber)":
                payload_list.append(self.add_side_info_to_payload("a_side", payload_to_change))
        if "z_side_info" in self.payload.keys():
            payload_to_change = self.payload.get("z_side_info")
            # Payload mod (1 of 5): Add internal field/key 'side' into payload to retain side info
            payload_list.append(self.add_side_info_to_payload("z_side", payload_to_change))
        return payload_list

    def build_payload_for_task(self, task, interim_payload):
        if not task:
            abort(500, "SupportedProdTemplate.build_payload_for_task - Task is unknown")
        if not interim_payload:
            abort(500, "SupportedProdTemplate.build_payload_for_task - Payload is unknown")
        completed_payload = {}
        # Payload mod (2 of 5): Add internal field/key 'role' in the payload for the following specified tasks
        if task == "Create_MTU_Shelf":
            interim_payload = self.add_role_info_to_payload("mtu", interim_payload)
        elif task == "Create_CPE_Shelf":
            interim_payload = self.add_role_info_to_payload("cpe", interim_payload)
        elif task == "Create_VGW_Shelf":
            interim_payload = self.add_role_info_to_payload("vgw", interim_payload)
        # Payload mod (3 of 5): Add key:value pairs from carryover payload to interim payload, if needed
        carryover_payload_keys_map = self.get_order_task_carryover_payload_keys_map()
        task_list_to_check = carryover_payload_keys_map.get(self.order)
        if task_list_to_check:
            for item in task_list_to_check:
                task_to_check = item[0]
                keys_to_create = item[1]
                carryover_keys = item[2]
                if task_to_check == task:
                    for i, key_to_create in enumerate(keys_to_create):
                        try:
                            # Add key:value from carryover payload to interim payload that is being built
                            interim_payload[key_to_create] = self.carryover_payload[carryover_keys[i]]
                        except KeyError:
                            # If key doesn't exist in carryover payload, it will not be created in the interim payload
                            pass
        # Payload mod (4 of 5): Add port role into payload to distinguish which assignment call is being made
        if task in {"Assign_Uplinks", "Assign_VGW_Uplinks"}:
            interim_payload = self.add_port_role_info_to_payload("uplink", interim_payload)
        if task in {"Assign_Handoffs", "Assign_VGW_Handoffs"}:
            interim_payload = self.add_port_role_info_to_payload("handoff", interim_payload)
        # Get the expected payload keys
        expected_payload_keys = self.get_task_payload_keys_map().get(task)
        logger.debug(f"SupportedProdTemplate.build_payload_for_task.expected_payload_keys - {expected_payload_keys}")
        # Payload mod (5 of 5): Build payload for task by comparing each expected key:value pair with what is available
        #  in the interim payload
        for key in expected_payload_keys:
            if self.is_payload_key_optional(key):
                key = key[0]
            # Add a key to the completed payload for the task only if it is explicitly defined
            # in the interim payload
            if key in interim_payload.keys():
                completed_payload[key] = interim_payload.get(key)
        return completed_payload

    def get_payload_for_task(self, task, payload):
        if not task:
            abort(500, "SupportedProdTemplate.get_payload_for_task - Task is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.get_payload_for_task - Payload is unknown")
        payload_for_task = self.build_payload_for_task(task, payload)
        return payload_for_task

    def check_payload_keys_for_task(self, task, payload):
        if not task:
            abort(500, "SupportedProdTemplate.check_payload_keys_for_task - Task is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.check_payload_keys_for_task - Payload is unknown")
        missing_keys = []
        keys_with_no_value = []
        expected_payload_keys = self.task_payload_keys_map.get(task)
        logger.debug(
            f"SupportedProdTemplate.check_payload_keys_for_task.expected_payload_keys - {expected_payload_keys}"
        )
        for key in expected_payload_keys:
            if self.is_payload_key_optional(key):
                key = key[0]
            elif key not in payload.keys():
                missing_keys.append(key)
            elif not payload.get(key):
                keys_with_no_value.append(key)
        logger.debug(
            "SupportedProdTemplate.check_payload_keys_for_task.missing_keys - "
            f"{missing_keys} in {payload.get('side')} for task {task}"
        )
        logger.debug(
            "SupportedProdTemplate.check_payload_keys_for_task.keys_with_no_value - "
            f"{keys_with_no_value} in {payload.get('side')} for task {task}"
        )
        if missing_keys and keys_with_no_value:
            abort(
                500,
                "SupportedProdTemplate.check_payload_keys_for_task - "
                f"Missing payload keys {missing_keys} and payload keys without values {keys_with_no_value} "
                f"in {payload.get('side')} for task {task}",
            )
        elif missing_keys:
            abort(
                500,
                "SupportedProdTemplate.check_payload_keys_for_task - "
                f"Missing payload keys {missing_keys} in {payload.get('side')} for task {task}",
            )
        elif keys_with_no_value:
            abort(
                500,
                "SupportedProdTemplate.check_payload_keys_for_task - "
                f"Payload keys without values {keys_with_no_value} in {payload.get('side')} for task {task}",
            )

    def feed_payload_through_model(self, task, payload):
        model = self.task_main_func_to_model_map[task]
        payload = model(**payload)
        return payload.model_dump()

    # Task functions
    def get_list_of_tasks_for_order(self):
        if not self.order:
            abort(500, "SupportedProdTemplate.get_list_of_tasks_for_order - Order is unknown")
        order_tasks_map = self.get_order_tasks_map()
        return order_tasks_map.get(self.order)

    def get_func_for_task(self, task):
        if not task:
            abort(500, "SupportedProdTemplate.get_api_by_task - Task is unknown")
        task_microservice_main_funcs = self.get_task_microservice_main_funcs()
        return task_microservice_main_funcs.get(task)

    def execute_each_task(self, task_list, payload):
        # checking payload side to see if its a_side or z_side info so we do not abort (epl logic)
        if not task_list and payload.get("side", "") == "z_side_info":
            abort(500, "SupportedProdTemplate.execute_each_task - Task list is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.execute_each_task - Payload is unknown")
        for task in task_list:
            logger.debug(f"SupportedProdTemplate.execute_each_task - Task - {task}")
            main_func = self.get_func_for_task(task)
            payload_for_task = self.get_payload_for_task(task, payload)
            logger.debug(f"SupportedProdTemplate.execute_each_task - Payload for task - {payload_for_task}")
            self.check_payload_keys_for_task(task, payload_for_task)
            payload_for_task = self.feed_payload_through_model(task, payload_for_task)
            self.execution_output.append(f"   {task}")
            resp = main_func(payload_for_task)
            logger.debug(f"SupportedProdTemplate.execute_each_task - Response - {resp}")
            self.update_carryover_payload(resp)
            logger.debug(f"SupportedProdTemplate.execute_each_task - Carryover payload - {self.carryover_payload}")
            self.execution_output.append(resp)

    # Helper functions
    def get_method_and_endpoint_for_api(self, api):
        if not api:
            abort(500, "SupportedProdTemplate.get_method_and_endpoint_for_api - API is unknown")
        method = None
        endpoint = None
        data = api.split(" ")
        if len(data) > 1:
            method = data[0]
            endpoint = data[1]
        else:
            endpoint = data[0]
        return method, endpoint

    def call_sense_endpoint(self, method, endpoint, task, payload):
        if not endpoint:
            abort(500, "SupportedProdTemplate.call_sense_endpoint - Endpoint is unknown")
        if not payload:
            abort(500, "SupportedProdTemplate.call_sense_endpoint - Payload is unknown")
        if method == "POST":
            order = post_sense(endpoint, payload, timeout=300)
        elif method == "PUT":
            order = put_sense(endpoint, payload, timeout=300)
        elif method == "GET":
            order = get_sense(endpoint, payload, timeout=300)
        else:
            # Return mock data
            if task == "Create_CPE_Shelf":
                order = (
                    self.mock_response.get("Create_CPE_Shelf_trunked")
                    if "uni_type" in payload.keys() and "Trunked" in payload.values()
                    else self.mock_response.get("Create_CPE_Shelf")
                )
            else:
                order = self.mock_response.get(task)
        return order

    # Mock data section
    mock_response = {
        "Create_MTU_Shelf": {
            "mtu_shelf": "string",
            "mtu_tid": "string",
            "mtu_uplink": "string",
            "mtu_handoff": "string",
            "mtu_pe_path": "string",
        },
        "Create_CPE_Shelf": {
            "cpe_shelf": "string",
            "cpe_tid": "string",
            "cpe_uplink": "string",
            "cpe_handoff": "string",
            "zw_path": "string",
            "circ_path_inst_id": "string",
        },
        "Create_CPE_Shelf_trunked": {
            "cpe_shelf": "string",
            "cpe_tid": "string",
            "cpe_uplink": "string",
            "cpe_trunked_path": "string",
            "cpe_handoff": "string",
            "cpe_handoff_paid": "string",
            "circ_path_inst_id": "string",
        },
        "Create_MTU_Transport": {
            "message": "mtu_new_build_transport_name has been successfully created and added to path_name.",
            "mtu_new_build_transport_name": "string",
            "mtu_new_build_transport": "string",
        },
        "Serviceable_Shelf": {
            "cpe_shelf": "string",
            "cpe_tid": "string",
            "cpe_handoff": "string",
            "cpe_handoff_paid": "string",
            "zw_transport_path": "string",
            "zw_transport_path_inst_id": "string",
            "circ_path_inst_id": "string",
        },
        "Assign_Uplinks": {"message": "MTU Uplink or CPE Uplink has been added successfully."},
        "Assign_Handoffs": {"message": "CPE Handoff has been added successfully."},
        "Assign_Parent_Paths": {"message": "Parent Paths & Cloud has been added successfully."},
        "Quick_Connect_Transport_Path": {"transport_path": "51001.GE1.AUSDTXIR2QW.AUSZTXOC2ZW"},
        "Assign_ENNI": {"message": "ENNI has been added successfully."},
        "Assign_EVC": {"message": "EVC ID has been added successfully."},
        "Assign_VPLS": {"customers_elan_name": "VPLS has been added successfully."},
        "Assign_GSIP_Attributes": {"message": "GSIP Attributes have been added successfully."},
    }
